package org.spiderland.Psh;

import java.util.ArrayList;

/**
 * Semantic interpreter
 */
public class SemanticInterpreter extends Interpreter {

	/**
	 * Generates list of all possible programs with given size
	 * @param size size of the programs
	 * @return
	 */
	public ArrayList<Program> generateAllPrograms(int size) {
		return generateAllPrograms(size, false);
	}
	
	/**
	 * Generates list of all possible programs with given size. Resulting set
	 * may consist numbers generated by ERC's
	 * 
	 * @param size
	 * @param containNumbers
	 * @return
	 */
	public ArrayList<Program> generateAllPrograms(int size, boolean containNumbers) {
		ArrayList<Program> set = new ArrayList<Program>();
		
		if (size > 0)
			generateAllPrograms(set, new Program(), size, containNumbers);
		
		return set;
	}
	
	private void generateAllPrograms(ArrayList<Program> set, Program program, int size, boolean containNumbers) {
		if (size == 0) {
			set.add((Program) program.clone());
		} else {
			for (AtomGenerator generator : _randomGenerators)
				if (containNumbers
						|| (generator instanceof InstructionAtomGenerator)) {
					program.push(generator.Generate(this));
					generateAllPrograms(set, program, size-1, containNumbers);
					program.pop();
				}
		}
	}
	
	public InterpreterState getState() {
		InterpreterState state = new InterpreterState(this);
//		state.setFloatStack(_floatStack);
//		state.setIntStack(_intStack);
//		state.setBoolStack(_boolStack);
//		state.setInputStack(_inputStack);
//		state.setNameStack(_nameStack);
//		state.setCodeStack(_codeStack);
		return state;
	}
	
	public void setState(InterpreterState state) {
		_floatStack = state.getFloatStack();
		_intStack = state.getIntStack();
		_boolStack = state.getBoolStack();
		_inputStack = state.getInputStack();
		_nameStack = state.getNameStack();
		_codeStack = state.getCodeStack();
		UpdateStackInstructions();
	}
	
	public ArrayList<AtomGenerator> getRandomGenerators() {
		return this._randomGenerators;
	}
}
